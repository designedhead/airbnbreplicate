"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _react = _interopRequireWildcard(require("react"));

var _creatable = _interopRequireDefault(require("react-select/creatable"));

var _reactSelect = _interopRequireDefault(require("react-select"));

var _default2 = _interopRequireDefault(require("part:@sanity/components/fieldsets/default"));

var _patchEvent = _interopRequireWildcard(require("part:@sanity/form-builder/patch-event"));

var _formBuilder = require("part:@sanity/form-builder");

var _client = _interopRequireDefault(require("part:@sanity/base/client"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// @ts-nocheck
var client = _client.default.withConfig({
  apiVersion: '2021-03-25'
});

var createPatchFrom = value => _patchEvent.default.from(value === "" ? (0, _patchEvent.unset)() : (0, _patchEvent.set)(value));

var FrozenAndEmptyWarning = () => /*#__PURE__*/_react.default.createElement("p", null, "Objects of type ", "'", "tags", "'", " must have a ", "'", "preload", "'", " value if they", "'", "re frozen, as no new tags may be added to a frozen tag set");

var autocompleteTagsComponent = (0, _react.forwardRef)((props, ref) => {
  var {
    type,
    level
  } = props;
  var [isLoading, setIsLoading] = (0, _react.useState)(false);
  var [selected, setSelected] = (0, _react.useState)([]);
  var options = props.type.options || {};
  var preloadedTags = options.preload || [];
  var closeMenuOnSelect = options.closeMenuOnSelect !== false;
  var frozen = options.frozen === true;
  var [uniqueTags, setUniqueTags] = (0, _react.useState)(preloadedTags); // TODO: This doesn't work, obviously :( Gotta fix it

  (0, _react.useImperativeHandle)(ref, () => ({
    focus() {
      this._inputElement.focus();
    }

  })); // We'll use this document type later to query and patch it

  var document = props.document._type; // On component load, let's fetch all tags from all images and only keep unique ones

  (0, _react.useEffect)(() => {
    // Component is loading! Hands off!
    setIsLoading(true); // Query for the document type and return the whole thing

    var query = "*[_type == $document && count(tags) > 0].tags[]";

    var fetchTags = /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2.default)(function* () {
        var allTags = yield client.fetch(query, {
          document
        }); // Now, let's create a new array that only includes unique tags

        var uniqueTags = [];
        var map = new Map();

        for (var tag of allTags) {
          if (!map.has(tag.value)) {
            map.set(tag.value, true);
            uniqueTags.push({
              value: tag.value,
              label: tag.label
            });
          }
        }

        setUniqueTags(uniqueTags);
      });

      return function fetchTags() {
        return _ref.apply(this, arguments);
      };
    }(); // Ok, now let's populate the dropdown with tags already assigned.


    var setSelectedTags = /*#__PURE__*/function () {
      var _ref2 = (0, _asyncToGenerator2.default)(function* () {
        // populating existing tags from document props (this is why we need to set CDN to `false`: to make sure props have fresh set of tags)
        // let's make sure selected !== null and is always an array
        setSelected(!props.value ? [] : props.value);
      });

      return function setSelectedTags() {
        return _ref2.apply(this, arguments);
      };
    }();

    if (!frozen) {
      fetchTags();
    }

    setSelectedTags(); // Component no longer loading

    setIsLoading(false);
  }, []); // Here we handle change to the tags when this change does not involve creating a new tag

  var handleChange = value => {
    // again, ensuring that `selected` remains an array
    setSelected(!value ? [] : value);
    props.onChange(createPatchFrom(!value ? [] : value));
  };
  /*
  Ok, here's some fun: here we handle changes that involve creating new tags and populating these new options into selected tags and all tags
  */


  var selectMenuProps = {
    disabled: isLoading,
    isLoading,
    value: selected ? selected : [],
    isMulti: true,
    options: uniqueTags || "",
    onChange: handleChange,
    closeMenuOnSelect
  };

  if (!frozen) {
    selectMenuProps.onCreateOption = inputValue => {
      var newSelected = selected;
      newSelected.push({
        value: inputValue,
        label: inputValue
      });
      setSelected(newSelected); // New tags need to be commited to Sanity so that we can reuse them elsewhere

      client.patch(props.document._id).append(document, [{
        value: inputValue,
        label: inputValue
      }]).commit().then(() => props.onChange(createPatchFrom(newSelected)));
    };
  }

  return /*#__PURE__*/_react.default.createElement(_default2.default, {
    level: level,
    legend: type.title,
    description: type.description
  }, frozen && preloadedTags.length === 0 ? /*#__PURE__*/_react.default.createElement(FrozenAndEmptyWarning, null) : null, frozen ? /*#__PURE__*/_react.default.createElement(_reactSelect.default, selectMenuProps) : /*#__PURE__*/_react.default.createElement(_creatable.default, selectMenuProps));
});

var _default = (0, _formBuilder.withDocument)(autocompleteTagsComponent);

exports.default = _default;